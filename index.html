<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Home - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/Ragudos" target="_blank" class="menu-item" id="repository" >My GitHub</a></h2><h3>Classes</h3><ul><li><a href="module-utils_debug_errors-UnimplementedError.html">utils/debug/errors~UnimplementedError</a></li><li><a href="module-utils_debug_errors-UnsupportedError.html">utils/debug/errors~UnsupportedError</a></li></ul><h3>Modules</h3><ul><li><a href="module-core_png.html">core/png</a><ul class='members'><li data-type='member' style='display: none;'><a href="module-core_png.html#.PNG_SIGNATURE">PNG_SIGNATURE</a></li></ul></li><li><a href="module-utils_debug_assert.html">utils/debug/assert</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_debug_assert.html#~assert">assert</a></li></ul></li><li><a href="module-utils_debug_errors.html">utils/debug/errors</a></li><li><a href="module-utils_is.html">utils/is</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_is.html#~isArray">isArray</a></li><li data-type='method' style='display: none;'><a href="module-utils_is.html#~isFunction">isFunction</a></li><li data-type='method' style='display: none;'><a href="module-utils_is.html#~isNumber">isNumber</a></li><li data-type='method' style='display: none;'><a href="module-utils_is.html#~isPlainObject">isPlainObject</a></li><li data-type='method' style='display: none;'><a href="module-utils_is.html#~isString">isString</a></li></ul></li><li><a href="module-utils_numbers_const.html">utils/numbers/const</a></li></ul><h3>Global</h3><ul><li><a href="global.html#JsNumber">JsNumber</a></li><li><a href="global.html#NumberType">NumberType</a></li><li><a href="global.html#bytesTo16BitUint">bytesTo16BitUint</a></li><li><a href="global.html#bytesTo24BitUint">bytesTo24BitUint</a></li><li><a href="global.html#bytesTo32BitUint">bytesTo32BitUint</a></li><li><a href="global.html#getBitAt">getBitAt</a></li><li><a href="global.html#getNumberType">getNumberType</a></li><li><a href="global.html#int16ToBytes">int16ToBytes</a></li><li><a href="global.html#int24ToBytes">int24ToBytes</a></li><li><a href="global.html#int32ToBytes">int32ToBytes</a></li><li><a href="global.html#int8ToBytes">int8ToBytes</a></li><li><a href="global.html#isSigned24Bit">isSigned24Bit</a></li><li><a href="global.html#isSignedByte">isSignedByte</a></li><li><a href="global.html#isSignedInt">isSignedInt</a></li><li><a href="global.html#isSignedShort">isSignedShort</a></li><li><a href="global.html#isUnsigned24Bit">isUnsigned24Bit</a></li><li><a href="global.html#isUnsignedByte">isUnsignedByte</a></li><li><a href="global.html#isUnsignedShort">isUnsignedShort</a></li><li><a href="global.html#numToBytes">numToBytes</a></li><li><a href="global.html#uint16ToBytes">uint16ToBytes</a></li><li><a href="global.html#uint24ToBytes">uint24ToBytes</a></li><li><a href="global.html#uint32ToBytes">uint32ToBytes</a></li><li><a href="global.html#uint8ToBytes">uint8ToBytes</a></li></ul>
    
</nav>

<div id="main">
    

    



    


    <section class="package">
        <h3> </h3>		
    </section>









    



    <section class="readme usertext">
        <article><h1>Image Parser</h1>
<p>This is a work-in-progress</p>
<h2>Resources</h2>
<p>Below are the resources and applications I use to understand the concepts in this repository.</p>
<ul>
<li><a href="https://bitwisecmd.com/">bitwisecmd, Bitwise Calculator</a></li>
<li><a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html">libpng, Information about PNG</a></li>
<li><a href="https://www.w3schools.com/js/js_bitwise.asp">W3Schools, Basic knowledge about bitwise operators</a></li>
</ul>
<h2>License</h2>
<p>This project is licensed under the Creative Commons Attribution 4.0 International License (CC BY 4.0).</p>
<h3>Key Points:</h3>
<ul>
<li><strong>You can:</strong> Share, copy, redistribute, remix, transform, and build upon the material for any purpose, even commercially.</li>
<li><strong>You must:</strong> Give appropriate credit to the original author(s), provide a link to the license, and indicate if changes were made. You may do this in any reasonable manner, but not in a way that suggests endorsement by the licensor.</li>
</ul>
<p>For full license details, please refer to the <a href="https://github.com/Ragudos/Image-Parser/blob/master/LICENSE">LICENSE</a> file or visit <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</p>
<hr>
<p>Copyright (c) 2024 Aaron Ragudos</p></article>
    </section>









<section>

<header>
    
        <h2>
        
            utils/src/numbers/compute/conversion.js
        
        </h2>
        
    
</header>

<article>
    
        <div class="container-overview">
        
            

<dl class="details">
    
    <dt class="tag-description">Description:</dt>
    <dd class="tag-description"><ul class="dummy"><li><p>All main operations for conversions</p>
<p><strong>Note</strong>:</p>
<ul>
<li>Floating points are not supported</li>
</ul>
<p>Operations used by this file:</p>
<ul>
<li><code>&gt;&gt;&gt;</code> right shift and adding leading zeroes</li>
<li><code>&gt;&gt;</code> right shift and adding the copy of leftmost bit</li>
<li><code>&lt;&lt;</code> left shift</li>
<li><code>|</code> OR operator</li>
<li><code>&amp;</code> AND operator</li>
</ul>
<p>Bytes to number operations will shift
the most significant byte (MSB) in Big-Endian format, while
the least significant byte in Little-Endian format, to the left,
from the desired bit width, going down by 8 for each following
byte until all bytes have been combined using the OR (|) bitwise operator.</p>
<p>Bytes to int and vice versa does things, well, vice versa. If we convert
bytes to int by shifting the bytes to the left based on their significance, then
we shift a number to the right to get the byte equivalent of each 8-bit section
of the number.</p>
<p>To convert bytes to a signed integer, then we must check whether it can indeed
be a signed integer by checking its respective bit width.</p>
<p>To do this, the resulting unsigned integer will be masked by the
maximum of the values of respective signed integers' bits <code>plus 1</code>.</p>
<p>For example, if we convert two bytes
to an integer, a 16-bit uint will be acquired.</p>
<p>Then, if a 16-bit int is desired, we mask it by <code>0x8000</code> or <code>32_768</code>
to check if the value is negative in signed format. If it is,
then subtract it by the maximum value of 16-bit uint <code>plus 1</code>, which is <code>0x10000</code>
or <code>65536</code>. The result will be the 16-bit int value of the two bytes.</p>
<p>How does this work? Well, try masking <code>-127</code> to <code>0xff</code> or <code>255</code>, and you'll
get <code>129</code>. Do this continuously until <code>-1</code>, and you'll soon reach <code>255</code>.</p>
<p>In essence, the reason why signed integers have lower positive values than their equivalent
unsigned integers is to account for the negative values.</p>
<p>Thus, if a value is greater than the max of its signed format's positive value, then it's
a negative value in its signed format.</p></li></ul></dd>
    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="utils_src_numbers_compute_conversion.js.html">utils/src/numbers/compute/conversion.js</a>, <a href="utils_src_numbers_compute_conversion.js.html#line23">line 23</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>




            
                <div class="description usertext"><p>All main operations for conversions</p>
<p><strong>Note</strong>:</p>
<ul>
<li>Floating points are not supported</li>
</ul>
<p>Operations used by this file:</p>
<ul>
<li><code>&gt;&gt;&gt;</code> right shift and adding leading zeroes</li>
<li><code>&gt;&gt;</code> right shift and adding the copy of leftmost bit</li>
<li><code>&lt;&lt;</code> left shift</li>
<li><code>|</code> OR operator</li>
<li><code>&amp;</code> AND operator</li>
</ul>
<p>Bytes to number operations will shift
the most significant byte (MSB) in Big-Endian format, while
the least significant byte in Little-Endian format, to the left,
from the desired bit width, going down by 8 for each following
byte until all bytes have been combined using the OR (|) bitwise operator.</p>
<p>Bytes to int and vice versa does things, well, vice versa. If we convert
bytes to int by shifting the bytes to the left based on their significance, then
we shift a number to the right to get the byte equivalent of each 8-bit section
of the number.</p>
<p>To convert bytes to a signed integer, then we must check whether it can indeed
be a signed integer by checking its respective bit width.</p>
<p>To do this, the resulting unsigned integer will be masked by the
maximum of the values of respective signed integers' bits <code>plus 1</code>.</p>
<p>For example, if we convert two bytes
to an integer, a 16-bit uint will be acquired.</p>
<p>Then, if a 16-bit int is desired, we mask it by <code>0x8000</code> or <code>32_768</code>
to check if the value is negative in signed format. If it is,
then subtract it by the maximum value of 16-bit uint <code>plus 1</code>, which is <code>0x10000</code>
or <code>65536</code>. The result will be the 16-bit int value of the two bytes.</p>
<p>How does this work? Well, try masking <code>-127</code> to <code>0xff</code> or <code>255</code>, and you'll
get <code>129</code>. Do this continuously until <code>-1</code>, and you'll soon reach <code>255</code>.</p>
<p>In essence, the reason why signed integers have lower positive values than their equivalent
unsigned integers is to account for the negative values.</p>
<p>Thus, if a value is greater than the max of its signed format's positive value, then it's
a negative value in its signed format.</p></div>
            

            
        
        </div>
    

    

    

    
    
    

     

    

    

    

    

    
</article>

</section>







<section>

<header>
    
        <h2>
        
            utils/src/numbers/compute/engine.js
        
        </h2>
        
    
</header>

<article>
    
        <div class="container-overview">
        
            

<dl class="details">
    
    <dt class="tag-description">Description:</dt>
    <dd class="tag-description"><ul class="dummy"><li><p>All main operations for computations</p>
<p><strong>Note</strong>:</p>
<ul>
<li>Floating points are not supported</li>
</ul>
<p>Functions in this file will use these bitwise operators:</p>
<ul>
<li><code>&lt;&lt;</code> left shift</li>
<li><code>&gt;&gt;</code> right shift (signed, will use the leftmost bit when shifting, preserving the integer's sign).</li>
<li><code>|</code> OR operator</li>
<li><code>&amp;</code> AND operator</li>
</ul>
<p>Even though all numbers in JavaScript are 64-bit double precision
floating points and converts operands of bitwise operations to int32.
for bitwise operations to work properly, it would still be nice to
check for a number's range (8-bit, 16-bit, etc.).</p>
<p>It's still logical to use a custom <code>Integer</code> class and using strings, but for the
sake of learning, I'm using bitwise operations if possible.</p>
<p>To give an example for the operations of the functions in this file:</p>
<p><a href="global.html#isSignedByte">isSignedByte</a> will check whether a number is int8.</p>
<p>Since all integers in JavaScript is 32-bit, this function will shift the number to the
left <code>24</code> bits and back to the right by <code>24</code> bits.</p>
<p>If the number is originally an 8-bit number, then the final result will still be
itself; otherwise, its significant bits (bits information after the least 8 bits) is lost.</p>
<p>Lastly, uint32 cannot be fully supported by JavaScript</p>
<p>See the table below to compare the binary representation of specific numbers to understand
how we can check their type using the mentioned operations:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Binary</th>
</tr>
</thead>
<tbody>
<tr>
<td>(Maximum int24) 8388607</td>
<td>0b00000000011111111111111111111111</td>
</tr>
<tr>
<td>8388608</td>
<td>0b00000000100000000000000000000000</td>
</tr>
<tr>
<td>(Maximum uint8) 255</td>
<td>0b00000000000000000000000011111111</td>
</tr>
<tr>
<td>256</td>
<td>0b00000000000000000000000100000000</td>
</tr>
<tr>
<td>(Maximum int32) 2_147_483_647</td>
<td>0b01111111111111111111111111111111</td>
</tr>
<tr>
<td>(Maximum uint32) 4_294_967_295</td>
<td>0b1111111111111111111111111111111</td>
</tr>
<tr>
<td>2_147_483_648</td>
<td>0b10000000000000000000000000000000</td>
</tr>
</tbody>
</table>
<p>The maximum uint32 should have more than 32 bits so it does not get represented as int32,
but that is not possible in JavaScript (weird, I know). Thus, this value will be interpreted
as int32 if operated with <code>num | 0</code>, having the value of <code>num | 0</code> not be equal to <code>num</code>.</p></li></ul></dd>
    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="utils_src_numbers_compute_engine.js.html">utils/src/numbers/compute/engine.js</a>, <a href="utils_src_numbers_compute_engine.js.html#line10">line 10</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li><a href="https://bitwisecmd.com/">https://bitwisecmd.com/</a></li>
        
            <li><a href="https://www.w3schools.com/js/js_bitwise.asp">https://www.w3schools.com/js/js_bitwise.asp</a> know how bit shifts work</li>
        
            <li><a href="https://byjus.com/maths/binary-number-system/">https://byjus.com/maths/binary-number-system/</a> to know about the binary number system</li>
        </ul>
    </dd>
    

    
</dl>




            
                <div class="description usertext"><p>All main operations for computations</p>
<p><strong>Note</strong>:</p>
<ul>
<li>Floating points are not supported</li>
</ul>
<p>Functions in this file will use these bitwise operators:</p>
<ul>
<li><code>&lt;&lt;</code> left shift</li>
<li><code>&gt;&gt;</code> right shift (signed, will use the leftmost bit when shifting, preserving the integer's sign).</li>
<li><code>|</code> OR operator</li>
<li><code>&amp;</code> AND operator</li>
</ul>
<p>Even though all numbers in JavaScript are 64-bit double precision
floating points and converts operands of bitwise operations to int32.
for bitwise operations to work properly, it would still be nice to
check for a number's range (8-bit, 16-bit, etc.).</p>
<p>It's still logical to use a custom <code>Integer</code> class and using strings, but for the
sake of learning, I'm using bitwise operations if possible.</p>
<p>To give an example for the operations of the functions in this file:</p>
<p><a href="global.html#isSignedByte">isSignedByte</a> will check whether a number is int8.</p>
<p>Since all integers in JavaScript is 32-bit, this function will shift the number to the
left <code>24</code> bits and back to the right by <code>24</code> bits.</p>
<p>If the number is originally an 8-bit number, then the final result will still be
itself; otherwise, its significant bits (bits information after the least 8 bits) is lost.</p>
<p>Lastly, uint32 cannot be fully supported by JavaScript</p>
<p>See the table below to compare the binary representation of specific numbers to understand
how we can check their type using the mentioned operations:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Binary</th>
</tr>
</thead>
<tbody>
<tr>
<td>(Maximum int24) 8388607</td>
<td>0b00000000011111111111111111111111</td>
</tr>
<tr>
<td>8388608</td>
<td>0b00000000100000000000000000000000</td>
</tr>
<tr>
<td>(Maximum uint8) 255</td>
<td>0b00000000000000000000000011111111</td>
</tr>
<tr>
<td>256</td>
<td>0b00000000000000000000000100000000</td>
</tr>
<tr>
<td>(Maximum int32) 2_147_483_647</td>
<td>0b01111111111111111111111111111111</td>
</tr>
<tr>
<td>(Maximum uint32) 4_294_967_295</td>
<td>0b1111111111111111111111111111111</td>
</tr>
<tr>
<td>2_147_483_648</td>
<td>0b10000000000000000000000000000000</td>
</tr>
</tbody>
</table>
<p>The maximum uint32 should have more than 32 bits so it does not get represented as int32,
but that is not possible in JavaScript (weird, I know). Thus, this value will be interpreted
as int32 if operated with <code>num | 0</code>, having the value of <code>num | 0</code> not be equal to <code>num</code>.</p></div>
            

            
        
        </div>
    

    

    

    
    
    

     

    

    

    

    

    
</article>

</section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.3</a> on Sat Aug 31 2024 12:36:51 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>