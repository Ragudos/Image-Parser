<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>utils/src/numbers/compute/conversion.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/Ragudos" target="_blank" class="menu-item" id="repository" >My GitHub</a></h2><h3>Classes</h3><ul><li><a href="CRC.html">CRC</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CRC.html#.calculateCRC">calculateCRC</a></li></ul></li><li><a href="module-utils_debug_errors-UnimplementedError.html">utils/debug/errors~UnimplementedError</a></li><li><a href="module-utils_debug_errors-UnsupportedError.html">utils/debug/errors~UnsupportedError</a></li></ul><h3>Modules</h3><ul><li><a href="module-core_png.html">core/png</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_png.html#~getIHDR">getIHDR</a></li><li data-type='method' style='display: none;'><a href="module-core_png.html#~getPNGChunks">getPNGChunks</a></li><li data-type='method' style='display: none;'><a href="module-core_png.html#~isValidPNG">isValidPNG</a></li><li data-type='method' style='display: none;'><a href="module-core_png.html#~processPNG">processPNG</a></li></ul></li><li><a href="module-utils_debug_assert.html">utils/debug/assert</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_debug_assert.html#~assert">assert</a></li></ul></li><li><a href="module-utils_debug_errors.html">utils/debug/errors</a></li><li><a href="module-utils_is.html">utils/is</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_is.html#~isArray">isArray</a></li><li data-type='method' style='display: none;'><a href="module-utils_is.html#~isFunction">isFunction</a></li><li data-type='method' style='display: none;'><a href="module-utils_is.html#~isNumber">isNumber</a></li><li data-type='method' style='display: none;'><a href="module-utils_is.html#~isPlainObject">isPlainObject</a></li><li data-type='method' style='display: none;'><a href="module-utils_is.html#~isString">isString</a></li></ul></li><li><a href="module-utils_numbers_compute_conversion.html">utils/numbers/compute/conversion</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~bytesTo16BitInt">bytesTo16BitInt</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~bytesTo16BitUint">bytesTo16BitUint</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~bytesTo24BitInt">bytesTo24BitInt</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~bytesTo24BitUint">bytesTo24BitUint</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~bytesTo32BitInt">bytesTo32BitInt</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~bytesTo32BitUint">bytesTo32BitUint</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~int16ToBytes">int16ToBytes</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~int24ToBytes">int24ToBytes</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~int32ToBytes">int32ToBytes</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~int8ToBytes">int8ToBytes</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~numToBytes">numToBytes</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~uint16ToBytes">uint16ToBytes</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~uint24ToBytes">uint24ToBytes</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~uint32ToBytes">uint32ToBytes</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_conversion.html#~uint8ToBytes">uint8ToBytes</a></li></ul></li><li><a href="module-utils_numbers_compute_engine.html">utils/numbers/compute/engine</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_engine.html#~getBitAt">getBitAt</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_engine.html#~getNumberType">getNumberType</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_engine.html#~isSigned24Bit">isSigned24Bit</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_engine.html#~isSignedByte">isSignedByte</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_engine.html#~isSignedInt">isSignedInt</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_engine.html#~isSignedShort">isSignedShort</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_engine.html#~isUnsigned24Bit">isUnsigned24Bit</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_engine.html#~isUnsignedByte">isUnsignedByte</a></li><li data-type='method' style='display: none;'><a href="module-utils_numbers_compute_engine.html#~isUnsignedShort">isUnsignedShort</a></li></ul></li><li><a href="module-utils_numbers_const.html">utils/numbers/const</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CRC.">CRC.</a></li><li><a href="global.html#PNG_SIGNATURE">PNG_SIGNATURE</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">utils/src/numbers/compute/conversion.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @license
 *
 * This code is licensed under the Creative Commons Attribution 4.0 International License (CC BY 4.0).
 * See the LICENSE file for details.
 * Full license text: https://creativecommons.org/licenses/by/4.0/
 * Copyright (c) 2024 Aaron Ragudos
 */

const { UnsupportedError } = require("../../debug/errors");
const {
	MAX_UINT_32BIT,
	MAX_INT_16BIT_PLUS1,
	MAX_UINT_16BIT_PLUS1,
	MAX_INT_24BIT_PLUS1,
	MAX_UINT_24BIT_PLUS1,
} = require("../const");
const {
	isUnsignedByte,
	getNumberType,
	isSignedInt,
	isSignedByte,
	isSignedShort,
	isUnsignedShort,
	isSigned24Bit,
	isUnsigned24Bit,
} = require("./engine");

/**
 *
 * @fileoverview
 * All main operations for conversions
 *
 * **Note**:
 * - Floating points are not supported
 *
 * Operations used by this file:
 * - `>>>` right shift and adding leading zeroes
 * - `>>` right shift and adding the copy of leftmost bit
 * - `&lt;&lt;` left shift
 * - `|` OR operator
 * - `&amp;` AND operator
 *
 * Bytes to number operations will shift
 * the most significant byte (MSB) in Big-Endian format, while
 * the least significant byte in Little-Endian format, to the left,
 * from the desired bit width, going down by 8 for each following
 * byte until all bytes have been combined using the OR (|) bitwise operator.
 *
 * Bytes to int and vice versa does things, well, vice versa. If we convert
 * bytes to int by shifting the bytes to the left based on their significance, then
 * we shift a number to the right to get the byte equivalent of each 8-bit section
 * of the number.
 *
 * To convert bytes to a signed integer, then we must check whether it can indeed
 * be a signed integer by checking its respective bit width.
 *
 * To do this, the resulting unsigned integer will be masked by the
 * maximum of the values of respective signed integers' bits `plus 1`.
 *
 * For example, if we convert two bytes
 * to an integer, a 16-bit uint will be acquired.
 *
 * Then, if a 16-bit int is desired, we mask it by `0x8000` or `32_768`
 * to check if the value is negative in signed format. If it is,
 * then subtract it by the maximum value of 16-bit uint `plus 1`, which is `0x10000`
 * or `65536`. The result will be the 16-bit int value of the two bytes.
 *
 * How does this work? Well, try masking `-127` to `0xff` or `255`, and you'll
 * get `129`. Do this continuously until `-1`, and you'll soon reach `255`.
 *
 * In essence, the reason why signed integers have lower positive values than their equivalent
 * unsigned integers is to account for the negative values.
 *
 * Thus, if a value is greater than the max of its signed format's positive value, then it's
 * a negative value in its signed format.
 *
 * @module utils/numbers/compute/conversion
 */

/**
 *
 * @param {number} highestByte
 * @param {number} lowestByte
 * @param {boolean} [littleEndian]
 *
 * @returns {number}
 *
 * @throws {RangeError} if `highByte` nor `lowByte` is not a byte
 */
function bytesTo16BitUint(highestByte, lowestByte, littleEndian) {
	if (!isUnsignedByte(highestByte) || !isUnsignedByte(lowestByte)) {
		throw new RangeError();
	}

	if (littleEndian) {
		return (lowestByte &lt;&lt; 8) | highestByte;
	}

	return (highestByte &lt;&lt; 8) | lowestByte;
}

/**
 *
 * @param {number} highestByte
 * @param {number} lowestByte
 * @param {boolean} [littleEndian]
 *
 * @returns {number}
 *
 * @throws {RangeError} if `highByte` nor `lowByte` is not a byte
 */
function bytesTo16BitInt(highestByte, lowestByte, littleEndian) {
	let int16 = bytesTo16BitUint(highestByte, lowestByte, littleEndian);

	if (int16 &amp; MAX_INT_16BIT_PLUS1) {
		int16 -= MAX_UINT_16BIT_PLUS1;
	}

	return int16;
}

/**
 *
 * @param {number} highestByte
 * @param {number} midByte
 * @param {number} lowestByte
 * @param {boolean} [littleEndian]
 *
 * @returns {number}
 *
 * @throws {RangeError} if `highestByte`, `midByte`, nor `lowestByte` is not a byte
 */
function bytesTo24BitUint(highestByte, midByte, lowestByte, littleEndian) {
	if (
		!isUnsignedByte(highestByte) ||
		!isUnsignedByte(midByte) ||
		!isUnsignedByte(lowestByte)
	) {
		throw new RangeError();
	}

	if (littleEndian) {
		return (lowestByte &lt;&lt; 16) | (midByte &lt;&lt; 8) | highestByte;
	}

	return (highestByte &lt;&lt; 16) | (midByte &lt;&lt; 8) | lowestByte;
}

/**
 *
 * @param {number} highestByte
 * @param {number} midByte
 * @param {number} lowestByte
 * @param {boolean} [littleEndian]
 *
 * @returns {number}
 *
 * @throws {RangeError} if `highByte` nor `lowByte` is not a byte
 */
function bytesTo24BitInt(highestByte, midByte, lowestByte, littleEndian) {
	let int24 = bytesTo24BitUint(
		highestByte,
		midByte,
		lowestByte,
		littleEndian
	);

	if (int24 &amp; MAX_INT_24BIT_PLUS1) {
		int24 -= MAX_UINT_24BIT_PLUS1;
	}

	return int24;
}

/**
 *
 * @param {number} highestByte
 * @param {number} firstMidByte
 * @param {number} secondMidByte
 * @param {number} lowestByte
 * @param {boolean} [littleEndian]
 *
 * @returns {number}
 *
 * @throws {RangeError} if `highestByte`, `firstMidByte`, `secondMidByte` nor `lowestByte` is not a byte
 */
function bytesTo32BitUint(
	highestByte,
	firstMidByte,
	secondMidByte,
	lowestByte,
	littleEndian
) {
	return (
		bytesTo32BitInt(
			highestByte,
			firstMidByte,
			secondMidByte,
			lowestByte,
			littleEndian
		) >>> 0
	);
}

/**
 *
 * @param {number} highestByte
 * @param {number} firstMidByte
 * @param {number} secondMidByte
 * @param {number} lowestByte
 * @param {boolean} [littleEndian]
 *
 * @returns {number}
 *
 * @throws {RangeError} if `highestByte`, `firstMidByte`, `secondMidByte` nor `lowestByte` is not a byte
 */
function bytesTo32BitInt(
	highestByte,
	firstMidByte,
	secondMidByte,
	lowestByte,
	littleEndian
) {
	if (
		!isUnsignedByte(highestByte) ||
		!isUnsignedByte(firstMidByte) ||
		!isUnsignedByte(secondMidByte) ||
		!isUnsignedByte(lowestByte)
	) {
		throw new RangeError();
	}

	if (littleEndian) {
		return (
			(lowestByte &lt;&lt; 24) |
			(secondMidByte &lt;&lt; 16) |
			(firstMidByte &lt;&lt; 8) |
			highestByte
		);
	}

	return (
		(highestByte &lt;&lt; 24) |
		(firstMidByte &lt;&lt; 16) |
		(secondMidByte &lt;&lt; 8) |
		lowestByte
	);
}

/**
 *
 * @param {number} num
 * @param {boolean} [skipCheck] **Only toggle this as true if you know what you're doing.**
 *
 * @returns {Array&lt;number>}
 *
 * @throws {RangeError} if `num` is not uint8 when checked
 */
function uint8ToBytes(num, skipCheck) {
	if (!skipCheck) {
		if (!isUnsignedByte(num)) {
			throw new RangeError();
		}
	}

	return [num];
}

/**
 *
 * @param {number} num
 * @param {boolean} [skipCheck] **Only toggle this as true if you know what you're doing.**
 *
 * @returns {Array&lt;number>}
 *
 * @throws {RangeError} if `num` is not int8 when checked
 */
function int8ToBytes(num, skipCheck) {
	if (!skipCheck) {
		if (!isSignedByte(num)) {
			throw new RangeError();
		}
	}

	return [num &amp; 0xff];
}

/**
 *
 * @param {number} num
 * @param {boolean} [skipCheck] **Only toggle this as true if you know what you're doing.**
 * @param {boolean} [littleEndian]
 *
 * @returns {Array&lt;number>}
 *
 * @throws {RangeError} if `num` is not int16 when checked
 */
function int16ToBytes(num, skipCheck, littleEndian) {
	if (!skipCheck) {
		if (!isSignedShort(num)) {
			throw new RangeError();
		}
	}

	const highestByte = (num >> 8) &amp; 0xff;
	const lowestByte = num &amp; 0xff;

	if (littleEndian) {
		return [lowestByte, highestByte];
	}

	return [highestByte, lowestByte];
}

/**
 * Does not mask the result of `num >> 8` to `0xff`
 *
 * @param {number} num
 * @param {boolean} [skipCheck] **Only toggle this as true if you know what you're doing.**
 * @param {boolean} [littleEndian]
 *
 * @returns {Array&lt;number>}
 *
 * @throws {RangeError} if `num` is not uint16
 */
function uint16ToBytes(num, skipCheck, littleEndian) {
	if (!skipCheck) {
		if (!isUnsignedShort(num)) {
			throw new RangeError();
		}
	}

	const highestByte = num >> 8;
	const lowestByte = num &amp; 0xff;

	if (littleEndian) {
		return [lowestByte, highestByte];
	}

	return [highestByte, lowestByte];
}

/**
 *
 * @param {number} num
 * @param {boolean} [skipCheck] **Only toggle this as true if you know what you're doing.**
 * @param {boolean} [littleEndian]
 *
 * @returns {Array&lt;number>}
 *
 * @throws {RangeError} if `num` is not int24
 */
function int24ToBytes(num, skipCheck, littleEndian) {
	if (!skipCheck) {
		if (!isSigned24Bit(num)) {
			throw new RangeError();
		}
	}

	const highestByte = (num >> 16) &amp; 0xff;
	const midByte = (num >> 8) &amp; 0xff;
	const lowestByte = num &amp; 0xff;

	if (littleEndian) {
		return [lowestByte, midByte, highestByte];
	}

	return [highestByte, midByte, lowestByte];
}

/**
 *
 * We don't mask the `highestByte` since we assert that `num` is not negative.
 *
 * @param {number} num
 * @param {boolean} [skipCheck] **Only toggle this as true if you know what you're doing.**
 * @param {boolean} [littleEndian]
 *
 * @returns {Array&lt;number>}
 *
 * @throws {RangeError} if `num` is not int24
 */
function uint24ToBytes(num, skipCheck, littleEndian) {
	if (!skipCheck) {
		if (!isUnsigned24Bit(num)) {
			throw new RangeError();
		}
	}

	const highestByte = num >> 16;
	const midByte = (num >> 8) &amp; 0xff;
	const lowestByte = num &amp; 0xff;

	if (littleEndian) {
		return [lowestByte, midByte, highestByte];
	}

	return [highestByte, midByte, lowestByte];
}

/**
 *
 * @param {number} num
 * @param {boolean} [skipCheck] **Only toggle this as true if you know what you're doing.**
 * @param {boolean} [littleEndian]
 *
 * @returns {Array&lt;number>}
 *
 * @throws {RangeError} if `num` is not int32 when checked
 */
function int32ToBytes(num, skipCheck, littleEndian) {
	if (!skipCheck) {
		if (!isSignedInt(num)) {
			throw new RangeError();
		}
	}

	const highestByte = (num >> 24) &amp; 0xff;
	const firstMidByte = (num >> 16) &amp; 0xff;
	const secondMidByte = (num >> 8) &amp; 0xff;
	const lowestByte = num &amp; 0xff;

	if (littleEndian) {
		return [lowestByte, secondMidByte, firstMidByte, highestByte];
	}

	return [highestByte, firstMidByte, secondMidByte, lowestByte];
}

/**
 *
 * @param {number} num
 * @param {boolean} [skipCheck] **Only toggle this as true if you know what you're doing.**
 * @param {boolean} [littleEndian]
 *
 * @returns {Array&lt;number>}
 *
 * @throws {RangeError} if `num` is not uint32 when checked
 */
function uint32ToBytes(num, skipCheck, littleEndian) {
	if (!skipCheck) {
		if (num &lt; 0 || num > MAX_UINT_32BIT) {
			throw new RangeError();
		}
	}

	const highestByte = (num >> 24) &amp; 0xff;
	const firstMidByte = (num >> 16) &amp; 0xff;
	const secondMidByte = (num >> 8) &amp; 0xff;
	const lowestByte = num &amp; 0xff;

	if (littleEndian) {
		return [lowestByte, secondMidByte, firstMidByte, highestByte];
	}

	return [highestByte, firstMidByte, secondMidByte, lowestByte];
}

/**
 *
 * @param {module:utils/numbers/compute/engine.JsNumber} num
 * @param {module:utils/numbers/compute/engine.NumberType} [convertTo]
 * @param {boolean} [littleEndian]
 *
 * @returns {Array&lt;number>}
 *
 * @throws {UnsupportedError | RangeError} if `num` exceeds the maximum value a 32-bit unsigned integer can hold, or an operation is unsupported.
 */
function numToBytes(num, convertTo, littleEndian) {
	if (typeof num === "bigint") {
		throw new UnsupportedError();
	}

	if (num > MAX_UINT_32BIT) {
		throw new RangeError();
	}

	const numberType = convertTo ? convertTo : getNumberType(num);

	switch (numberType) {
		case "int8":
			return int8ToBytes(num, true);

		case "uint8":
			return uint8ToBytes(num, true);

		case "int16":
			return int16ToBytes(num, true, littleEndian);

		case "uint16":
			return uint16ToBytes(num, true, littleEndian);

		case "int24":
			return int24ToBytes(num, true, littleEndian);

		case "uint24":
			return uint24ToBytes(num, true, littleEndian);

		case "int32":
			return int32ToBytes(num, true, littleEndian);

		case "uint32":
			return uint32ToBytes(num, true, littleEndian);

		default:
			throw new UnsupportedError();
	}
}

module.exports = {
	bytesTo16BitUint,
	bytesTo24BitUint,
	bytesTo32BitUint,
	bytesTo16BitInt,
	bytesTo24BitInt,
	bytesTo32BitInt,
	int8ToBytes,
	int16ToBytes,
	int24ToBytes,
	int32ToBytes,
	uint8ToBytes,
	uint16ToBytes,
	uint24ToBytes,
	uint32ToBytes,
	numToBytes,
};
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.3</a> on Tue Sep 03 2024 14:00:06 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
